#+TITLE: Emacs config
#+AUTHOR: Erick Navarro

* Vanilla Emacs setup

#+BEGIN_SRC emacs-lisp

  (setq inhibit-startup-message t)
  (setq default-directory (expand-file-name "~/"))

  ;; Hide the bell in the center of screen
  (setq ring-bell-function 'ignore)
  (column-number-mode t)
  (global-hl-line-mode 1)

  (when (member "Monaco" (font-family-list))
      (set-frame-font "Monaco 12"))

  (global-set-key (kbd "C-x -") 'my/decrease-font-height)
  (global-set-key (kbd "C-x =") 'my/increase-font-height)
  (global-set-key (kbd "C-x +") 'my/increase-font-height)

  ;; Navigate through buffers
  (global-set-key (kbd "M-[") 'previous-buffer)
  (global-set-key (kbd "M-]") 'next-buffer)

  ;; Fix unicode errors
  (setenv "LANG" "en_US.UTF-8")
  (setenv "LC_ALL" "en_US.UTF-8")
  (setenv "LC_CTYPE" "en_US.UTF-8")

  ;; Fix size of scroll
  (setq scroll-step 1
        scroll-conservatively  10000)

  ;; Show a marker when the line has empty characters at the end
  (setq-default show-trailing-whitespace t)

  ;; Avoid close emacs by mistake
  (global-unset-key (kbd "C-x C-c"))

  (defalias 'yes-or-no-p 'y-or-n-p)
  (defalias 'run-elisp 'ielm)

  ;; place custom code generated for emacs in a separate file
  (defconst custom-file (expand-file-name ".customize.el" user-emacs-directory))
  (load custom-file :noerror)

#+END_SRC

Setup fira code symbols mode.

#+BEGIN_SRC emacs-lisp

  (when (member "Fira Code" (font-family-list))
    (load-file (expand-file-name "~/.emacs.d/fira-code-mode.el"))
    (require 'fira-code-mode)
    (add-hook 'prog-mode-hook 'fira-code-mode))

#+END_SRC

Adjust font size to screen resolution, increase font size for 4K screens

#+BEGIN_SRC emacs-lisp

  (when (and (display-graphic-p) (>= (x-display-pixel-width) 3840))
    (set-frame-font "Monaco 16"))

#+END_SRC

Parrot mode FTW!

#+BEGIN_SRC emacs-lisp

  (defun my/parrot-animate-when-compile-success (buffer result)
    (if (string-match "^finished" result)
        (parrot-start-animation)))

  (use-package parrot
    :ensure t
    :config
    (parrot-mode)
    (add-hook 'before-save-hook 'parrot-start-animation)
    (add-to-list 'compilation-finish-functions 'my/parrot-animate-when-compile-success))

#+END_SRC

Open scratch buffer

#+BEGIN_SRC emacs-lisp

  (defun my/scratch-buffer()
    "Switch to scratch buffer."
    (interactive)
    (let ((buffer (get-buffer "*scratch*")))
      (if buffer
          (switch-to-buffer buffer)
        (switch-to-buffer (get-buffer-create "*scratch*"))
        (insert initial-scratch-message))
      (lisp-interaction-mode)))

#+END_SRC

** Ansi term

For some reason ansi-term doesn't respect the global keybinding for =M-]= so this have to be setup in =term-raw-map= as well.

#+BEGIN_SRC emacs-lisp

  (eval-after-load "term"
    '(define-key term-raw-map (kbd "M-]") 'next-buffer))

#+END_SRC

** Compilation

Disable =h= key-binding, this has a conflict with evil-mode left navigation key-binding.

#+BEGIN_SRC emacs-lisp

  (eval-after-load "compile"
    '(define-key compilation-mode-map (kbd "h") nil))

#+END_SRC

Allow to show color characters in the compilation buffer.

copied from https://stackoverflow.com/questions/3072648/cucumbers-ansi-colors-messing-up-emacs-compilation-buffer/3072831#3072831

#+BEGIN_SRC emacs-lisp

  (require 'ansi-color)

  (defun colorize-compilation-buffer ()
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region (point-min) (point-max))))

  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)

#+END_SRC

* Better defaults

#+BEGIN_SRC emacs-lisp

  (use-package better-defaults
    :ensure t
    :config
    (menu-bar-mode 1))

#+END_SRC

* Theme and styles

** Dracula

#+BEGIN_SRC emacs-lisp

  (use-package dracula-theme
    :ensure t
    :config
    (load-theme 'dracula t)
    (set-face-foreground 'font-lock-variable-name-face "gray"))

#+END_SRC

** Doom modeline

Enable =display-battery-mode= after =doom-modeline= is loaded.

#+BEGIN_SRC emacs-lisp

  (use-package doom-modeline
    :ensure t
    :defer t
    :custom
    (doom-modeline-modal-icon nil)
    :hook (after-init . doom-modeline-mode)
    :config (add-hook 'doom-modeline-mode-hook '(lambda () (display-battery-mode))))

#+END_SRC

** All the icons

#+BEGIN_SRC emacs-lisp

  (use-package all-the-icons
    :ensure t)

#+END_SRC

* Dired

#+BEGIN_SRC emacs-lisp

  (eval-after-load "dired"
    '(define-key dired-mode-map (kbd "C-c C-e") 'wdired-change-to-wdired-mode))

#+END_SRC

Dired preview mode, allow to see a preview of the file at point.

#+BEGIN_SRC emacs-lisp

  (use-package peep-dired
    :ensure t
    :init
    (setq peep-dired-cleanup-on-disable t)
    :after dired
    :config
    (define-key dired-mode-map (kbd "C-c C-p") 'peep-dired))

#+END_SRC

** All the icons dired

#+BEGIN_SRC emacs-lisp

  (use-package all-the-icons-dired
    :ensure t
    :defer t
    :hook (dired-mode . all-the-icons-dired-mode))

#+END_SRC

** Dired subtree

#+BEGIN_SRC emacs-lisp

  (use-package dired-subtree
    :ensure t
    :after dired
    :config
    (define-key dired-mode-map (kbd "<tab>") 'dired-subtree-toggle))

#+END_SRC

* Editor enhancements

** Dark and transparent title bar in macOS

#+BEGIN_SRC emacs-lisp

  (when (memq window-system '(mac ns))
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
    (add-to-list 'default-frame-alist '(ns-appearance . dark)))

#+END_SRC

** Share clipoard with OS

#+BEGIN_SRC emacs-lisp

  (use-package pbcopy
    :ensure t)

#+END_SRC

** Highlight TODO, FIXME, etc

#+BEGIN_SRC emacs-lisp

  (defun my/highlight-todo-like-words ()
    (font-lock-add-keywords
     nil `(("\\<\\(FIXME\\|TODO\\)"
            1 font-lock-warning-face t))))

  (add-hook 'prog-mode-hook 'my/highlight-todo-like-words)

#+END_SRC

** Load PATH environment

#+BEGIN_SRC emacs-lisp

  (use-package exec-path-from-shell
    :ensure t
    :custom
    (exec-path-from-shell-check-startup-files nil)
    :config
    (when (memq window-system '(mac ns))
      (exec-path-from-shell-initialize)))

#+END_SRC

** Editorconfig

#+BEGIN_SRC emacs-lisp

  (use-package editorconfig
    :ensure t
    :diminish ""
    :config
    (editorconfig-mode 1))

#+END_SRC

** Snippets

#+BEGIN_SRC emacs-lisp

  (use-package yasnippet
    :ensure t
    :diminish ""
    :hook ((prog-mode . yas-minor-mode)
           (conf-mode . yas-minor-mode)
           (text-mode . yas-minor-mode)
           (snippet-mode . yas-minor-mode)))

  (use-package yasnippet-snippets
    :ensure t
    :after (yasnippet))

#+END_SRC

** Wakatime

#+BEGIN_SRC emacs-lisp

  (use-package wakatime-mode
    :ensure t
    :if (executable-find "wakatime")
    :init
    (setq wakatime-cli-path (executable-find "wakatime"))
    :config
    (global-wakatime-mode))

#+END_SRC

** Highlight thing

#+BEGIN_SRC emacs-lisp

  (use-package highlight-thing
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'highlight-thing-mode))

#+END_SRC

** Various changes

Disable lock files

#+BEGIN_SRC emacs-lisp

  (setq create-lockfiles nil)

#+END_SRC

** Reformatter

#+BEGIN_SRC emacs-lisp

  (use-package reformatter
    :ensure t)

#+END_SRC

** Toggle terminal

#+BEGIN_SRC emacs-lisp

  (use-package eshell-toggle
    :ensure t
    :custom
    (eshell-toggle-init-function #'(lambda (dir)
                                     (my/goto-term)))
    :config
    (global-set-key [f2] 'eshell-toggle))

#+END_SRC

** iSpell

Avoid check spelling in markdown code blocks

#+BEGIN_SRC emacs-lisp

  (eval-after-load "ispell"
    '(add-to-list 'ispell-skip-region-alist
                  '("^```" . "^```")))

#+END_SRC

* Evil

#+BEGIN_SRC emacs-lisp

  (use-package evil
    :ensure t
    :init
    (setq evil-emacs-state-cursor '("white" box)
          evil-normal-state-cursor '("green" box)
          evil-visual-state-cursor '("orange" box)
          evil-insert-state-cursor '("red" bar))
    :config
    (evil-mode 1)
    (modify-syntax-entry ?_ "w")
    (define-key evil-normal-state-map (kbd "C-p") 'git-gutter:previous-hunk)
    (define-key evil-normal-state-map (kbd "C-n") 'git-gutter:next-hunk)
    (add-hook 'prog-mode-hook #'(lambda ()
                                  (modify-syntax-entry ?_ "w")))

    (face-spec-set
     'evil-ex-substitute-matches
     '((t :foreground "red"
          :strike-through t
          :weight bold)))

    (face-spec-set
     'evil-ex-substitute-replacement
     '((t
        :foreground "green"
        :weight bold))))

  (use-package evil-nerd-commenter
    :ensure t
    :after (evil)
    :config
    (evilnc-default-hotkeys)
    (global-set-key (kbd "C-\-") 'evilnc-comment-operator))

  (use-package evil-surround
    :ensure t
    :after (evil)
    :config
    (global-evil-surround-mode 1))

  (use-package evil-leader
    :ensure t
    :after (evil)
    :config
    (global-evil-leader-mode)
    (evil-leader/set-key
      "SPC" 'helm-M-x
      "a" 'my/helm-ag-with-default-term
      "A" 'my/helm-ag-without-default-term
      "b" 'helm-buffers-list
      "e" 'my/find-file-in-project
      "f" 'find-file
      "g" 'my/magit-status
      "hk" 'git-gutter:revert-hunk
      "hs" 'git-gutter:stage-hunk
      "k" 'kill-buffer
      "l" 'display-line-numbers-mode
      "n" 'evil-buffer-new
      "pa" 'my/copy-abs-path
      "pr" 'my/copy-relative-path
      "q" 'helm-swoop
      "s" 'my/toggle-spanish-characters
      "t" 'my/find-tag
      "w" 'my/toggle-maximize
      "x" 'my/resize-window
      "y" 'helm-show-kill-ring))

  (use-package evil-anzu
    :ensure t
    :after (evil))

  (use-package evil-matchit
    :ensure t
    :config (global-evil-matchit-mode 1))

#+END_SRC

* Utils

** Which-key

#+BEGIN_SRC emacs-lisp

  (use-package which-key
    :ensure t
    :diminish ""
    :config
    (which-key-mode)
    (which-key-setup-minibuffer))

#+END_SRC

** Autopair

#+BEGIN_SRC emacs-lisp

  (use-package autopair
    :ensure t
    :diminish ""
    :config
    (autopair-global-mode))

#+END_SRC

** Restclient

#+BEGIN_SRC emacs-lisp

  (use-package restclient
    :ensure t
    :defer t
    :mode (("\\.http\\'" . restclient-mode))
    :bind (:map restclient-mode-map
                ("C-c C-f" . json-mode-beautify))) ;TODO: change to only apply json formatting when the content-type is application/json

  (use-package restclient-helm
    :ensure t
    :after (restclient))

  (use-package company-restclient
    :ensure t
    :after (restclient)
    :config
    (add-to-list 'company-backends 'company-restclient))

#+END_SRC

** Rainbow delimiters

#+BEGIN_SRC emacs-lisp

  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))

#+END_SRC

** XML formatter

#+BEGIN_SRC emacs-lisp

  (reformatter-define xml-format
    :program "xmlformat"
    :group 'xml)

  (eval-after-load "nxml-mode"
    '(define-key nxml-mode-map (kbd "C-c C-f") 'xml-format-buffer))

#+END_SRC

** SQL formatter

Install =pgformatter= using homebrew =brew install pgformatter=

#+BEGIN_SRC emacs-lisp

  (reformatter-define sql-format
    :program "pg_format")

  (defun my/format-sql ()
    "Format active region otherwise format the entire buffer."
    (interactive)
    (if (region-active-p)
        (sql-format-region (region-beginning) (region-end))
      (sql-format-buffer)))

  (eval-after-load "sql"
    '(define-key sql-mode-map (kbd "C-c C-f") 'my/format-sql))

#+END_SRC

* Common packages

Used in every major mode

** Company

#+BEGIN_SRC emacs-lisp

  (use-package company
    :ensure t
    :init
    (setq company-idle-delay 0.1
          company-tooltip-limit 10
          company-minimum-prefix-length 3)
    :hook (after-init . global-company-mode)
    :config
    (define-key company-active-map (kbd "C-n") 'company-select-next)
    (define-key company-active-map (kbd "C-p") 'company-select-previous))

#+END_SRC

** Flycheck

#+BEGIN_SRC emacs-lisp

  (use-package flycheck
    :ensure t
    :diminish ""
    :bind (:map flycheck-mode-map
                ("M-p" . flycheck-previous-error)
                ("M-n" . flycheck-next-error))
    :config
    (global-flycheck-mode)
    (setq flycheck-highlighting-mode 'lines))

#+END_SRC

** Direnv

This allow to update environment using =.envrc= file.

#+BEGIN_SRC emacs-lisp

  (use-package direnv
    :ensure t
    :config
    (defun my/direnv-edit ()
      "Edit .envrc file for the current project."
      (interactive)
      (find-file (concat (projectile-project-root) ".envrc"))))

#+END_SRC

** Projectile

#+BEGIN_SRC emacs-lisp

  (use-package projectile
    :ensure t
    :delight '(:eval (format "Proj[%s]" (projectile-project-name)))
    :init
    (setq projectile-keymap-prefix (kbd "C-c p")
          projectile-switch-project-action 'helm-ls-git-ls
          projectile-completion-system 'helm)
    :config
    (projectile-mode))

#+END_SRC

** Helm

#+BEGIN_SRC emacs-lisp

  (use-package helm
    :ensure t
    :diminish ""
    :custom
    (helm-M-x-use-completion-styles nil)
    :config
    (require 'helm-config)
    (helm-mode 1)
    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    (setq helm-split-window-inside-p t)
    (add-to-list 'display-buffer-alist
                 '("\\`\\*helm.*\\*\\'"
                   (display-buffer-in-side-window)
                   (inhibit-same-window . t)
                   (window-height . 0.4))))

  (use-package helm-ag
    :ensure t
    :init
    (defun my/helm-ag-with-default-term ()
      (interactive)
      (let ((helm-ag-insert-at-point 'word))
        (helm-ag-project-root)))

    (defun my/helm-ag-without-default-term ()
      (interactive)
      (let ((helm-ag-insert-at-point nil))
        (helm-ag-project-root))))

  (use-package helm-ls-git
    :ensure t)

  (use-package helm-swoop
    :ensure t)

#+END_SRC

** Helm backup

This allows to create backups of edited files using a git repitory. The backup folder is located in =~/.helm-backup=

#+BEGIN_SRC emacs-lisp

  (use-package helm-backup
    :ensure t
    :config
    (add-hook 'after-save-hook 'helm-backup-versioning))

#+END_SRC

** Neotree

#+BEGIN_SRC emacs-lisp

  (use-package neotree
    :ensure t
    :init
    (setq neo-window-fixed-size nil
          neo-fit-to-contents t
          neo-theme 'icons
          neo-vc-integration (quote (face)))
    (defun my/neotree-toggle ()
      (interactive)
      (if (and (projectile-project-p) (not (neo-global--window-exists-p)))
          (my/neotree-open-projectile)
        (neotree-toggle)))
    :config
    (global-set-key [f3] 'my/neotree-toggle)
    (evil-set-initial-state 'neotree-mode 'emacs)
    (add-hook 'neotree-mode-hook
              (lambda ()
                (evil-emacs-state)
                (local-set-key (kbd "C-w l") 'evil-window-right)
                (local-set-key (kbd "C-c C-h") 'neotree-hidden-file-toggle)
                (local-set-key (kbd "C-c C-r") 'neotree-rename-node))))

#+END_SRC

* Orgmode

Configured variables:

- =org-latex-caption-above= puts table captions at the bottom
- =org-clock-persist= persists time even if emacs is closed
- =org-src-fontify-natively= enables syntax highlighting for code blocks
- =org-log-done= saves the timestamp when a task is done

#+BEGIN_SRC emacs-lisp

  (eval-after-load "org"
    `(progn
       (setq org-latex-caption-above nil
             org-clock-persist 'history
             org-src-fontify-natively t
             org-log-done t)
       (org-clock-persistence-insinuate)
       (add-hook 'org-mode-hook (lambda ()
                                  (org-indent-mode t)
                                  (diminish 'org-indent-mode)))
       (org-babel-do-load-languages 'org-babel-load-languages
                                    '((python . t)
                                      (shell . t)
                                      (lisp . t)
                                      (sql . t)
                                      (dot . t)
                                      (plantuml . t)
                                      (emacs-lisp . t)))))

  (use-package htmlize
    :ensure t
    :after (org))

#+END_SRC

** Org-ref

#+BEGIN_SRC emacs-lisp

  (use-package org-ref
    :ensure t
    :init
    (setq org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f")))

#+END_SRC

* Latex

#+BEGIN_SRC emacs-lisp

  (use-package auctex
    :ensure t
    :defer t)

  (use-package latex-preview-pane
    :ensure t)

#+END_SRC

* Git

** Git-link

Open selected region in remote repo page

#+BEGIN_SRC emacs-lisp

  (use-package git-link
    :ensure t)

#+END_SRC

** Gitignore-mode

#+BEGIN_SRC emacs-lisp

  (use-package gitignore-mode
    :ensure t)

#+END_SRC

** Magit

#+BEGIN_SRC emacs-lisp

  (use-package magit
    :ensure t
    :defer t
    :init
    (defconst my/magit-register ?m)
    (defun my/magit-status()
      (interactive)
      (set-register my/magit-register (current-window-configuration))
      (magit-status)
      (delete-other-windows))

    (defun my/magit-status-exit (&optional kill-buffer)
      "Restore windows configuration after magit status buffer is closed."
      (interactive)
      (let ((magit-buffer-name (format "magit: %s" (projectile-project-name)))
            (register-value (get-register my/magit-register)))
        (if (and register-value (string-equal magit-buffer-name (buffer-name)))
            (set-window-configuration register-value))))
    :config
    (advice-add 'magit-mode-bury-buffer :after 'my/magit-status-exit)
    (add-hook 'magit-blame-mode-hook
              (lambda ()
                (evil-emacs-state))))
#+END_SRC

** Magit TODOs

Show files containing =TODO= like text in =magit= status buffer.

#+BEGIN_SRC emacs-lisp

  (use-package magit-todos
    :ensure t
    :after (magit)
    :init
    (setq magit-todos-exclude-globs '("*.org"))
    :config
    (add-hook 'magit-status-mode-hook 'magit-todos-mode))

#+END_SRC

** Forge

#+BEGIN_SRC emacs-lisp

  (use-package forge
    :ensure t
    :after magit)

#+END_SRC

** Git-fringe

#+BEGIN_SRC emacs-lisp

  (use-package git-gutter-fringe
    :ensure t
    :if (display-graphic-p)
    :diminish git-gutter-mode
    :config
    (global-git-gutter-mode t))

  (use-package git-gutter
    :ensure t
    :if (not (display-graphic-p))
    :diminish git-gutter-mode
    :config
    (global-git-gutter-mode t))

#+END_SRC

** Git diff-hl

#+BEGIN_SRC emacs-lisp

  (use-package diff-hl
    :ensure t
    :config
    (add-hook 'dired-mode-hook 'diff-hl-dired-mode))

#+END_SRC

** Timemachine

#+BEGIN_SRC emacs-lisp

  (use-package git-timemachine
    :ensure t
    :config
    (add-hook 'git-timemachine-mode-hook (lambda ()
                                           (evil-emacs-state))))

#+END_SRC

** Gist

#+BEGIN_SRC emacs-lisp

  (use-package gist
    :ensure t)

#+END_SRC

** Linkode

#+BEGIN_SRC emacs-lisp

  (use-package linkode
    :ensure t
    :quelpa (linkode :fetcher github :repo "erickgnavar/linkode.el"))

#+END_SRC

* Web

** Web mode

#+BEGIN_SRC emacs-lisp

  (use-package web-mode
    :ensure t
    :init
    (setq web-mode-enable-current-element-highlight t
          web-mode-enable-current-column-highlight t)
    (defun my/web-mode-hook ()
      (emmet-mode)
      (rainbow-delimiters-mode-disable)
      (autopair-mode -1))
    :mode (("\\.html\\'" . web-mode)
           ("\\.html.eex\\'" . web-mode)
           ("\\.html.leex\\'" . web-mode)
           ("\\.hbs\\'" . web-mode))
    :config
    (add-hook 'web-mode-hook 'my/web-mode-hook))

#+END_SRC

** Emmet

#+BEGIN_SRC emacs-lisp

  (use-package emmet-mode
    :ensure t
    :diminish)

#+END_SRC

** Sass

#+BEGIN_SRC emacs-lisp

  (use-package sass-mode
    :ensure t)

#+END_SRC

** Rainbow

#+BEGIN_SRC emacs-lisp

  (use-package rainbow-mode
    :ensure t
    :diminish ""
    :config
    (add-hook 'css-mode-hook 'rainbow-mode)
    (add-hook 'sass-mode-hook 'rainbow-mode)
    (add-hook 'scss-mode-hook 'rainbow-mode))

#+END_SRC

* Miscellaneous

#+BEGIN_SRC emacs-lisp

  (use-package writeroom-mode
    :ensure t)

  (use-package csv-mode
    :ensure t)

  (use-package json-mode
    :ensure t)

  (use-package plantuml-mode
    :ensure t
    :config
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (setq org-plantuml-jar-path (expand-file-name "~/plantuml.jar")))

  (defun my/k8s-apply ()
    "Apply current yaml file to the current kubernetes context."
    (interactive)
    (let ((default-directory (file-name-directory buffer-file-name)))
      (compile (format "kubectl apply -f %s" buffer-file-name))))

  (use-package yaml-mode
    :ensure t
    :bind (:map yaml-mode-map
                ("C-c C-c" . 'my/k8s-apply)))

  ;; Used for gherkin files (.feature)
  (use-package feature-mode
    :ensure t)

  (use-package toml-mode
    :ensure t)

  (use-package markdown-mode
    :ensure t)

  (use-package dockerfile-mode
    :ensure t)

  (use-package dumb-jump
    :ensure t
    :init
    (setq dumb-jump-selector 'helm))

#+END_SRC

Use ESC key instead C-g to close and abort

Copied from somewhere

#+BEGIN_SRC emacs-lisp

  (defun minibuffer-keyboard-quit ()
    "Abort recursive edit.
  In Delete Selection mode, if the mark is active, just deactivate it;
  then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
      (setq deactivate-mark  t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))

  (eval-after-load "evil"
    '(progn
       (define-key evil-normal-state-map [escape] 'keyboard-quit)
       (define-key evil-visual-state-map [escape] 'keyboard-quit)))

  (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
  (global-set-key [escape] 'evil-exit-emacs-state)

#+END_SRC

Toggle hs-minor-mode

#+BEGIN_SRC emacs-lisp

  (eval-after-load "evil"
    '(define-key evil-normal-state-map (kbd "SPC") 'hs-toggle-hiding))

#+END_SRC

#+BEGIN_SRC emacs-lisp

  (diminish 'undo-tree-mode)
  (diminish 'hs-minor-mode)
  (diminish 'auto-revert-mode)

#+END_SRC

* Programming languages

** Python

  For each virtual environment install the following packages:

#+BEGIN_SRC sh
  pip install elpy jedi flake8 importmagic autopep8 yapf epc isort
#+END_SRC

#+BEGIN_SRC emacs-lisp

  (defun my/python-format-code ()
    (interactive)
    (if (executable-find "black")
        (blacken-buffer)
      (elpy-format-code)))

  (use-package elpy
    :ensure t
    :diminish
    :after (python)
    :config
    (elpy-enable)
    (when (require 'flycheck nil t)
      (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
      (add-hook 'elpy-mode-hook 'flycheck-mode))
    (evil-leader/set-key-for-mode 'python-mode "d" 'elpy-goto-definition)
    (define-key elpy-mode-map (kbd "C-c C-f") 'my/python-format-code)
    (setq elpy-rpc-python-command "python")
    (add-hook 'elpy-mode-hook
              (lambda ()
                (hs-minor-mode)
                (highlight-indentation-mode -1)))) ; Remove vertical line

  (setq python-shell-completion-native-enable nil)

  (use-package py-isort
    :ensure t
    :after (elpy)
    :init
    (defun my/sort-imports ()
      (interactive)
      (if (region-active-p)
          (py-isort-region)
        (message "Select a region before to call isort")))
    :bind (:map elpy-mode-map
                ("C-c C-i" . my/sort-imports)))

  (use-package blacken
    :ensure t)

#+END_SRC

Show a list of the available django commands and run the selected one using a compilation buffer.

#+BEGIN_SRC emacs-lisp

  (defun my/run-django-command ()
    "Run a django command."
    (interactive)
    (let* ((python-bin (concat (getenv "VIRTUAL_ENV") "/bin/python"))
           (manage-py-file (concat (projectile-project-root) "manage.py"))
           (default-directory (projectile-project-root))
           (raw-help (shell-command-to-string (concat python-bin " " manage-py-file " help")))
           (splited-lines (split-string raw-help "\n"))
           (options (seq-filter '(lambda (line) (cl-search "    " line)) splited-lines))
           (selection (completing-read "Pick django command: " (mapcar 'string-trim options)))
           (command (concat python-bin " " manage-py-file " " selection)))
      (compile command)))

#+END_SRC

** Erlang

Clone erlang source code into =~/Code/erlang/src/=

#+BEGIN_SRC sh

  git clone https://github.com/erlang/otp.git ~/Code/erlang/src/

#+END_SRC

#+BEGIN_SRC emacs-lisp

  (use-package erlang
    :ensure t
    :defer t
    :if (executable-find "erl")
    :config
    (setq erlang-root-dir (expand-file-name "~/Code/erlang/src"))
    (require 'erlang-start))

#+END_SRC

** Elixir

#+BEGIN_SRC emacs-lisp

  (reformatter-define elixir-format
    :program "mix"
    :args '("format" "-")
    :group 'elixir)

  (use-package elixir-mode
    :ensure t
    :bind (:map elixir-mode-map
                ("C-c C-t" . 'my/mix-run-test-at-point)
                ("C-c C-f" . elixir-format-buffer))
    :config
    (evil-leader/set-key-for-mode 'elixir-mode "d" 'dumb-jump-go))

#+END_SRC

Custom functions to run elixir tests.

=elixir-extra-test-env= can be set up on =.dir-locals.el=

#+BEGIN_SRC emacs-lisp

  (defun my/mix-run-test (&optional at-point)
    "If AT-POINT is true it will pass the line number to mix test."
    (interactive)
    (let* ((current-file (buffer-file-name))
           (current-line (line-number-at-pos))

           (possible-mix-paths `(,(concat (projectile-project-root) "mix.exs")
                                 ,(concat (projectile-project-root) "src/mix.exs")))
           (mix-file (car (seq-filter 'file-exists-p possible-mix-paths)))
           (default-directory (file-name-directory mix-file))
           (extra-env (if (boundp 'elixir-extra-test-env) elixir-extra-test-env ""))
           (mix-env (concat "MIX_ENV=test " extra-env)))

      (if at-point
          (compile (format "%s mix test %s:%s" mix-env current-file current-line))
        (compile (format "%s mix test %s" mix-env current-file)))))


  (defun my/mix-run-test-file ()
    "Run mix test over the current file."
    (interactive)
    (my/mix-run-test nil))

  (defun my/mix-run-test-at-point ()
    "Run mix test at point."
    (interactive)
    (my/mix-run-test t))

#+END_SRC

** LFE

#+BEGIN_SRC emacs-lisp

  (use-package lfe-mode
    :ensure t
    :if (executable-find "lfe")
    :bind (:map lfe-mode-map
                ("C-c C-c" . lfe-eval-buffer))
    :init
    (defun lfe-eval-buffer ()
      "Send current buffer to inferior LFE process."
      (interactive)
      (if (eq (get-buffer-window "*inferior-lfe*") nil)
          (run-lfe nil))
      (lfe-eval-region (point-min) (point-max) nil)))

#+END_SRC

** Elm

Install Elm

#+BEGIN_SRC sh

  npm -g install elm elm-format elm-oracle

#+END_SRC

#+BEGIN_SRC emacs-lisp

  (use-package elm-mode
    :ensure t
    :if (executable-find "elm")
    :bind (:map elm-mode-map
                ("C-c C-d" . elm-oracle-doc-at-point))
    :config
    (add-hook 'elm-mode-hook #'elm-oracle-setup-completion)
    (add-to-list 'company-backends 'company-elm))

#+END_SRC

** Haskell

Install haskell binaries =hlint= and =hindent= and make sure =~/.local/bin/= is loaded in =PATH=.

#+BEGIN_SRC shell

  stack install hlint
  stack install hindent

#+END_SRC

#+BEGIN_SRC emacs-lisp

  (reformatter-define haskell-format
    :program "hindent"
    :group 'haskell)

  (use-package haskell-mode
    :ensure t
    :bind (:map haskell-mode-map
                ("C-c C-f" . haskell-format-buffer)))

  (use-package intero
    :ensure t
    :config
    (add-hook 'haskell-mode-hook 'intero-mode)
    (evil-leader/set-key-for-mode 'haskell-mode "d" 'intero-goto-definition))

  (defun my/run-hlint ()
    "Run  hlint over the current project."
    (interactive)
    (let ((default-directory (projectile-project-root)))
      (compile "hlint .")))

  (defun my/run-hlint-buffer ()
    "Run  hlint over the current buffer."
    (interactive)
    (let* ((current-file (buffer-file-name))
           (default-directory (projectile-project-root)))
      (compile (concat "hlint " current-file))))

#+END_SRC

** Lua

#+BEGIN_SRC emacs-lisp

  (use-package lua-mode
    :ensure t
    :bind (:map lua-mode-map
                ("C-c C-b" . compile)))

  (use-package company-lua
    :ensure t
    :config
    (add-to-list 'company-backends 'company-lua))

#+END_SRC

** Javascript

Install tern

#+BEGIN_SRC sh

  npm -g install tern

#+END_SRC

#+BEGIN_SRC emacs-lisp

  (use-package js2-mode
    :ensure t
    :mode "\\.js\\'"
    :config
    ;; let the error checking to flycheck
    (setq js2-mode-show-strict-warnings nil))

  (use-package company-tern
    :ensure t
    :diminish tern-mode
    :after js2-mode
    :config
    (add-to-list 'company-backends 'company-tern)
    (add-hook 'js2-mode-hook 'tern-mode))

#+END_SRC

Formattter

Put this script in some =$PATH= location like =~/.local/bin=. This script is needed because prettier can't read code from stdin :/

#+BEGIN_SRC bash

  #!/bin/bash -

  tmp="$(mktemp).js"
  while read line
  do
      echo $line >> $tmp
  done < /dev/stdin

  prettier $tmp

#+END_SRC

#+BEGIN_SRC emacs-lisp

  (reformatter-define js-format
    :program "fixprettier.sh")

  (eval-after-load "js2-mode"
    `(define-key js2-mode-map (kbd "C-c C-f") 'js-format-buffer))

#+END_SRC

** Typescript

#+BEGIN_SRC emacs-lisp

  (use-package tide
    :ensure t
    :init
    (defun setup-tide-mode()
      (interactive)
      (tide-setup)
      (flycheck-mode +1)
      (setq flycheck-check-syntax-automatically '(save mode-enabled))
      (eldoc-mode +1)
      (tide-hl-identifier-mode +1)
      (company-mode +1))
    :config
    (add-hook 'typescript-mode-hook #'setup-tide-mode))

#+END_SRC

** Rust

Clone rust source code into =~/Code/rust/src/=

#+BEGIN_SRC sh

  git clone https://github.com/rust-lang/rust.git ~/Code/rust/src/

#+END_SRC

Install dependencies

#+BEGIN_SRC sh

  cargo install rustfmt
  cargo install racer

#+END_SRC

#+BEGIN_SRC emacs-lisp

  (use-package rust-mode
    :ensure t
    :if (executable-find "rustc"))

  (use-package cargo
    :ensure t
    :if (executable-find "cargo")
    :after rust-mode
    :bind (:map cargo-minor-mode-map
                ("C-c C-t" . cargo-process-test)
                ("C-c C-b" . cargo-process-build)
                ("C-c C-c" . cargo-process-run))
    :config
    (add-hook 'rust-mode-hook 'cargo-minor-mode))

  (use-package racer
    :ensure t
    :if (executable-find "racer")
    :diminish
    :after rust-mode
    :config
    (setq racer-rust-src-path (expand-file-name "~/Code/rust/src/src"))
    (evil-leader/set-key-for-mode 'rust-mode "d" 'racer-find-definition)
    (add-hook 'rust-mode-hook #'racer-mode)
    (add-hook 'racer-mode-hook #'eldoc-mode)
    (add-hook 'racer-mode-hook #'company-mode))

#+END_SRC

** Java

#+BEGIN_SRC emacs-lisp

  (use-package meghanada
    :ensure t
    :if (executable-find "java")
    :config
    (add-hook 'java-mode-hook (lambda ()
                                (meghanada-mode t))))

#+END_SRC

** Golang

Install dependencies: godef, goimports, gocode

#+BEGIN_SRC sh

  go get github.com/rogpeppe/godef
  go get golang.org/x/tools/cmd/goimports
  go get github.com/mdempsky/gocode

#+END_SRC

#+BEGIN_SRC emacs-lisp

  (use-package go-mode
    :ensure t
    :if (executable-find "go")
    :bind (:map go-mode-map
                ("C-c C-t" . go-test-current-file)
                ("C-c C-c" . go-run)
                ("C-c C-f" . gofmt))
    :config
    (setq gofmt-command "goimports")
    (evil-leader/set-key-for-mode 'go-mode "d" 'godef-jump))

  (use-package company-go
    :ensure t
    :if (executable-find "gocode")
    :after go-mode
    :config
    (add-to-list 'company-backends 'company-go))

  (use-package go-eldoc
    :ensure t
    :if (executable-find "gocode")
    :after go-mode
    :config
    (add-hook 'go-mode-hook 'go-eldoc-setup))

  (use-package go-playground
    :ensure t
    :if (executable-find "go")
    :after go-mode
    :config
    (setq go-playground-basedir (expand-file-name "~/Code/golang/playgrounds")))

#+END_SRC

** Common lisp

#+BEGIN_SRC emacs-lisp

  (defconst inferior-lisp-program (executable-find "sbcl"))

  (use-package sly
    :ensure t)

#+END_SRC

** Clojure

#+BEGIN_SRC emacs-lisp

  (use-package cider
    :ensure t
    :bind (:map cider-mode-map
                ("C-c C-f" . my/clj-format-code))
    :config
    (defun my/clj-format-code ()
      "Format clojure code using cider commands"
      (interactive)
      (if (region-active-p)
          (cider-format-region (region-beginning) (region-end))
        (cider-format-buffer))))

  (use-package clj-refactor
    :ensure t
    :after (cider)
    :config
    (defun my/clj-hook ()
      (clj-refactor-mode 1))
    (add-hook 'clojure-mode-hook #'my/clj-hook))

#+END_SRC

** Emacs lisp

Enable go to definition with \ d keybinding

#+BEGIN_SRC emacs-lisp

  (evil-leader/set-key-for-mode 'emacs-lisp-mode "d" 'xref-find-definitions)
  (evil-leader/set-key-for-mode 'lisp-interaction-mode "d" 'xref-find-definitions)

#+END_SRC

** OCaml

#+BEGIN_SRC emacs-lisp

  (use-package tuareg
    :ensure t)

  (use-package merlin
    :ensure t
    :hook ((tuareg-mode caml-mode) . merlin-mode))

  (use-package merlin-eldoc
    :ensure t
    :hook ((reason-mode tuareg-mode caml-mode) . merlin-eldoc-setup))

#+END_SRC

** Dart

#+BEGIN_SRC emacs-lisp

  (use-package dart-mode
    :ensure t
    :if (or (executable-find "dart") (executable-find "flutter"))
    :bind (:map dart-mode-map
                ("C-c C-f" . dart-format))
    :config
    (evil-leader/set-key-for-mode 'dart-mode "d" 'dart-goto))

#+END_SRC

** F-sharp

#+BEGIN_SRC emacs-lisp

  (use-package fsharp-mode
    :ensure t
    :defer t
    :if (executable-find "dotnet")
    :config
    (evil-leader/set-key-for-mode 'fsharp-mode "d" 'fsharp-ac/gotodefn-at-point))

#+END_SRC

* Custom functions

Manage window configurations, allows to save a "snapshot" of the current windows configuration. Also allows to restore a saved "snapshot".

#+BEGIN_SRC emacs-lisp

  (defvar my/window-snapshots '())

  (defun my/save-window-snapshot ()
    "Save the current window configuration into `window-snapshots` alist."
    (interactive)
    (let ((key (read-string "Enter a name for the snapshot: ")))
      (setf (alist-get key my/window-snapshots) (current-window-configuration))
      (message "%s window snapshot saved!" key)))

  (defun my/get-window-snapshot (key)
    "Given a KEY return the saved value in `window-snapshots` alist."
    (let ((value (assoc key my/window-snapshots)))
      (cdr value)))

  (defun my/restore-window-snapshot ()
    "Restore a window snapshot from the window-snapshots alist."
    (interactive)
    (let* ((snapshot-name (completing-read "Choose snapshot: " (mapcar #'car my/window-snapshots)))
           (snapshot (my/get-window-snapshot snapshot-name)))
      (if snapshot
          (set-window-configuration snapshot)
        (message "Snapshot %s not found" snapshot-name))))

#+END_SRC

Manipulate frame font height.

#+BEGIN_SRC emacs-lisp

  (defun my/change-font-height (delta)
    "Use DELTA to increase/decrease the frame font height."
    (let* ((current-height (face-attribute 'default :height))
           (new-height (+ current-height delta)))
      (set-face-attribute 'default (selected-frame) :height new-height)))

  (defun my/decrease-font-height ()
    "Decrease font height by 10."
    (interactive)
    (my/change-font-height -10))

  (defun my/increase-font-height ()
    "Increase font height by 10."
    (interactive)
    (my/change-font-height +10))

#+END_SRC

#+BEGIN_SRC emacs-lisp

  (defun my/goto-term ()
    "Create a new `ansi-term` buffer."
    (interactive)
    (if (projectile-project-p)
        (let* ((buffer-name (format "[%s]-ansi-term" (projectile-project-name)))
               (buffer-name-for-search (format "*%s*" buffer-name))
               (default-directory (projectile-project-root))
               (buffer (get-buffer buffer-name-for-search)))
          (if buffer
              (switch-to-buffer buffer)
            (ansi-term "/bin/zsh" buffer-name))
          (evil-insert-state))))

#+END_SRC

#+BEGIN_SRC emacs-lisp

  (defun my/find-file-in-project ()
    "Custom find file function."
    (interactive)
    (if (projectile-project-p)
        (helm-ls-git-ls)
        (helm-for-files)))

  (defun my/fold-buffer-when-is-too-big (max-lines)
    "Fold buffer is max lines if grater than as MAX-LINES."
    (if (> (count-lines (point-min) (point-max)) max-lines)
        (hs-hide-all)))

  (defun my/setup-eslint ()
    "If eslint is installed locally configure flycheck to use it."
    (interactive)
    (let ((local-eslint (concat (projectile-project-root) "node_modules/.bin/eslint")))
      (setq flycheck-javascript-eslint-executable (and (file-exists-p local-eslint) local-eslint))))

  (defun my/toggle-maximize ()
    "Toggle maximization of current window."
    (interactive)
    (let ((register ?w))
      (if (eq (get-register register) nil)
        (progn
          (set-register register (current-window-configuration))
          (delete-other-windows))
        (progn
          (set-window-configuration (get-register register))
          (set-register register nil)))))

  (defun my/venv-workon (name)
    "Active virtualenv NAME only is not setup yet."
    (unless pyvenv-virtual-env
      (pyvenv-workon name)))

  (defun my/config-file ()
    "Open config file."
    (interactive)
    (find-file (expand-file-name "~/.emacs.d/bootstrap.org")))

  (defun my/toggle-spanish-characters ()
    "Enable/disable alt key to allow insert spanish characters."
    (interactive)
    (if (eq ns-alternate-modifier 'meta)
        (setq ns-alternate-modifier nil)
        (setq ns-alternate-modifier 'meta)))

  (defun my/neotree-open-projectile ()
    "Open neotree with projectile root folfer."
    (interactive)
    (neotree-dir (projectile-project-root)))

  (defun my/change-font-size()
    "Change frame font size."
    (interactive)
    (let* ((size (read-number "New size: "))
           (font (format "Monaco %d" size)))
      (set-frame-font font)))

  (defun my/find-tag ()
    "Allow find a tag if the TAGS file exists, otherwise ask for create the file."
    (interactive)
    (if (projectile-project-p)
        (let
            ((tags-file-path (concat (projectile-project-root) "TAGS")))
          (if (f-exists-p tags-file-path)
              (helm-etags-select t)
            (if (yes-or-no-p "Do you want generate a TAGS file?")
                (progn
                  (my/gen-etags-file (projectile-project-root))
                  (helm-etags-select t)))))
      (message "You are not in a project.")))

  (defun my/force-build-tags ()
    "Force the build of the TAGS file."
    (interactive)
    (if (projectile-project-p)
        (my/gen-etags-file (projectile-project-root))
      (message "You are not in a project.")))

  (defun my/gen-etags-file (root-path)
    "Generate etags file for the ROOT-PATH folder."
    (let
        ((pattern (read-string "Enter pattern of files to be used: ")))
      (cd root-path)
      (shell-command (format "find . -name \"%s\" | etags -" pattern))))

#+END_SRC


Function to extract clocks from org buffer and filter them by month

#+BEGIN_SRC emacs-lisp

  (defun my/collect-clocks ()
    "Collect all the clocks of current buffer."
    (org-element-map (org-element-parse-buffer) 'clock
      (lambda (clock) clock)))

  (defun my/filter-clocks-by-month (clocks month)
    "Filter CLOCKS using MONTH value."
    (seq-filter '(lambda (clock)
                   (eq (org-element-property :month-end (org-element-property :value clock)) month)) clocks))

  (defun my/org-filter-clocks-report ()
    "Create a buffer with the tasks filtered by month."
    (interactive)
    (let* ((month (read-number "Insert month: "))
           (clocks (my/collect-clocks))
           (filtered-clocks (my/filter-clocks-by-month clocks month))
           (buffer (get-buffer-create "*clocks report*")))
      (switch-to-buffer buffer)
      (org-mode)
      (insert "* Report\n")
      (seq-map '(lambda (clock)
                  (insert (format "CLOCK: %s\n" (org-element-property :raw-value (org-element-property :value clock))))) filtered-clocks)
      (org-clock-display)))

#+END_SRC

Copy absolute and relative path to clipboard

#+BEGIN_SRC emacs-lisp

  (defun my/copy-abs-path ()
    "Copy absolute path of the buffer to clipboard"
    (interactive)
    (if buffer-file-name
        (progn
          (kill-new buffer-file-name)
          (message (format "%s copied to clipboard" buffer-file-name)))
      (message "File not saved yet")))

  (defun my/copy-relative-path ()
    "Copy relative path of the buffer to clipboard"
    (interactive)
    (if (and (projectile-project-p) buffer-file-name)
        (let ((path (file-relative-name buffer-file-name (projectile-project-root))))
          (kill-new path)
          (message (format "%s copied to clipboard" path)))
      (message "File not saved yet or not inside project")))

#+END_SRC

Create a temp file with the current buffer content and render it with =eww=.

#+BEGIN_SRC emacs-lisp

  (defun my/preview-buffer-in-eww ()
    "Preview buffer content in EWW."
    (interactive)
    (let* ((temp-file (make-temp-name (temporary-file-directory)))
           (path (concat temp-file ".html")))
      (write-file path)
      (kill-buffer)
      (eww-open-file path)))

#+END_SRC

Resize window: allow create a "resize mode" and use hjkl to increase/decrease width/height of the current window

#+BEGIN_SRC emacs-lisp

  (defun my/resize-window ()
    "Resize window using j k h l keys."
    (interactive)
    (let ((keys-map '((?h . evil-window-decrease-width)
                      (?j . evil-window-decrease-height)
                      (?k . evil-window-increase-height)
                      (?l . evil-window-increase-width)))
          (overlay (make-overlay (point-min) (point-max) (window-buffer))))
      (let ((is-reading t))
        (overlay-put overlay 'face '((t (:foreground "gray40"))))
        (while is-reading
          (let ((action (alist-get (read-key) keys-map)))
            (if action
                (apply action '(1))
              (setq is-reading nil)
              (delete-overlay overlay)))))))

#+END_SRC

Kill the current buffer and delete the related file

#+BEGIN_SRC emacs-lisp

  (defun my/delete-close-file ()
    "Delete the current file and kill its buffer."
    (interactive)
    (when buffer-file-name
      (delete-file buffer-file-name)
      (kill-buffer)))

#+END_SRC

Generate daily report for work.

#+BEGIN_SRC emacs-lisp

  (defun my/daily-template ()
    "Create a markdown formatter daily report."
    (interactive)
    (let* ((day (format-time-string "%A"))
           (prev-label-text (if (equal day "Monday") "Viernes" "Ayer"))
           (prev (read-string (concat prev-label-text ": ")))
           (today (read-string "Hoy: "))
           (problems (read-string "Impedimentos: ")))
      (kill-new (format "*%s*: %s\n*Hoy*: %s\n*Impedimentos*: %s" prev-label-text prev today problems))))

#+END_SRC

Open file given a highlighted region

#+BEGIN_SRC emacs-lisp

  (defun my/open-file-at-point()
    "Open the path selected if the file exists."
    (interactive)
    (when (region-active-p)
      (let ((path (buffer-substring (region-beginning) (region-end))))
        (if (file-exists-p path)
            (find-file path)
          (message "file not found")))))

#+END_SRC

** MacOS

Functions to open Finder using current file or current project.

#+BEGIN_SRC emacs-lisp

  (defun my/open-finder-at (path)
    "Open Finder app with the given PATH."
    (let* ((finder (executable-find "open"))
           (command (format "%s %s" finder path)))
      (shell-command command)))

  (defun my/open-project-in-finder ()
    "Open current project in Finder app."
    (interactive)
    (if (projectile-project-p)
        (my/open-finder-at (projectile-project-root))
      (message "There is no active project.")))

  (defun my/open-current-file-in-finder ()
    "Open current file in Finder."
    (interactive)
    (let ((file (buffer-file-name)))
      (if file
          (my/open-finder-at (file-name-directory file))
        (message "Buffer has not been saved yet!"))))

#+END_SRC

Open current file with an macOS app. Installed macOS apps will be listed using helm

#+BEGIN_SRC emacs-lisp

  (defun my/macos-open-file-with ()
    "Open current file with and macOS installed app."
    (interactive)
    (let* ((apps-list (directory-files "/Applications" nil "\\.app$"))
           (selected-app (completing-read "Choose an application: " apps-list)))
      (shell-command (format "open %s -a '%s'" (buffer-file-name) selected-app))))

#+END_SRC

Open the current file with macOS =open= command. This will open the file with the default app configured for the type of file.

#+BEGIN_SRC emacs-lisp

  (defun my/macos-open-current-file ()
    (interactive)
    (shell-command (format "open %s" (buffer-file-name))))

#+END_SRC
